---
title: "R Notebook"
output:
  pdf_document: default
  html_notebook: default
---


```{r}
source("Sampling_algorithm.r")
source("Johnson_SU_density.r")
source("Online update moments.r")
source("Johnson transformation with online update moment method.r")
source("Johnson transformation with MLE method.r")
source("Johnson transformation with perfect map.r")
```

```{r comparison after tunning parameters}
library(coda)
library(moments)
library(nleqslv)
# set the parameter
lambda_john <- 1
delta_john <- 0.5
xi_john <-  1
gamma_john <- 1
nits = 50000
pre_nits = 2000
h = 0.9
x_curr = 0
c = 500
delta = 0.5
t1_john = 3000

# define the density function with one parameter
d_logpi <- function(x) d_logJohnson (x,lambda_john,delta_john,xi_john,gamma_john)
log_pi <- function(x) log_dJohnson (x,lambda_john,delta_john,xi_john,gamma_john)

# Sampling by different algorithm
t1 <- Sys.time()
sample_MALA <- Adaptive_MALA(d_logpi,log_pi,nits, h,x_curr)
t2 <- Sys.time()
sample_RWM <- Adaptive_RWM(log_pi,nits,h,x_curr)
t3 <- Sys.time()
trans_john <- Transformation_johnsonsu_mom(log_pi,nits,x_curr,t1 = t1_john,delta = delta,c = c)
t4 <- Sys.time()
perfect_john <- Perfect_map_johnsonsu(log_pi,xi_john,lambda_john,delta_john,gamma_john)
t5 <- Sys.time()
pre_samples <- Adaptive_RWM(log_pi,pre_nits,h,x_curr)$x_store
trans_john_mle <- Sampling_trsanformation_johnsonsu_MLE (pre_samples,log_pi,nits,method = "MLE",x_curr = x_curr)
t6 <- Sys.time()

# print the ESS per sec
cat("the ESS per sec of MALA is: ",effectiveSize(sample_MALA$x_store) / as.numeric(t2- t1,units = "secs"),"\n")
cat("the ESS per sec of RWM is: ",effectiveSize(sample_RWM$x_store) / as.numeric(t3 - t2,units = "secs"),"\n")
cat("the ESS per sec of transformation method with Johnson SU (online update moment method) is: ",effectiveSize(trans_john$samples_x) / as.numeric(t4 - t3,units = "secs"),"\n")
cat('The ESS per sec of transformation method with Johnson SU (MLE method) is: ', effectiveSize(trans_john_mle$samples_x) / as.numeric(t6 - t5,units = "secs"),"\n")
cat("the ESS per sec of Perfect transformation is: ",effectiveSize(perfect_john$samples_x)/ as.numeric(t5 - t4,units = "secs"),"\n")


# compare the estimation precision
#define a function to compute the sample moments
compute_moments <- function(samples){
  mu <- apply(samples,2,mean)
  variance <- apply(samples,2,var)
  skew <- apply(samples,2,skewness)
  kurt <- apply(samples,2,kurtosis)
  return(rbind(mu,variance,skew,kurt))
}

delta_john <-0.5
# calculate the thoretical moments
mean_theory <- xi_john - lambda_john * exp(delta_john^-2 / 2) * sinh(gamma_john / delta_john)
var_theory <- (lambda_john^2 / 2) * (exp(delta_john^-2) - 1) *
  (exp(delta_john^-2) * cosh(2 * gamma_john / delta_john) + 1)

skew_theory <- -(lambda_john^3 * sqrt(exp(-delta_john^-2)) * (exp(delta_john^-2) - 1)^2 *
                   ((exp(delta_john^-2) * (exp(delta_john^-2) + 2)) * sinh(3 * gamma_john / delta_john) +
                      3 * sinh(gamma_john / delta_john))) / 4*(var_theory)^1.5

term <- exp(delta_john^-2)
K1 <- term^2 * (term^4 + 2 * term^3 + 3 * term^2 - 3) * cosh(4 * gamma_john / delta_john)
K2 <- 4 * term^2 * (term + 2) * cosh(3 * gamma_john / delta_john)
K3 <- 3 * (2 * term + 1)

kurt_theory <- (lambda_john^4 * (term - 1)^2 * (K1 + K2 + K3)) / (8 * (var_theory)^2) +3
theory_moment <- rbind(mean_theory,var_theory,skew_theory,kurt_theory)

# generate the perfect samples which exactly follows the target distribution
perfect_samples = lambda_john*sinh((rnorm(nits)-gamma_john)/delta_john)+xi_john

# create a matrix to store the estimation error
moment_error <- matrix(ncol = 4,nrow = 6)
colnames(moment_error) <- c("mean_diff","variance_diff","skew_diff","kurtosis_diff")
rownames(moment_error) <- c("Perfect sample","Adaptive MALA","Adaptive RWM","Johnson moment","Johnson MLE","Johnson perfect")
# calculate the difference between the moment from perfect samples and samples got by different sampling algorithm
moment_error["Perfect sample",] <- t(compute_moments(as.matrix(perfect_samples))-theory_moment)
moment_error["Adaptive MALA",] <- t(compute_moments(sample_MALA$x_store) - theory_moment)
moment_error["Adaptive RWM",] <- t(compute_moments(sample_RWM$x_store) - theory_moment)
moment_error["Johnson moment",] <- t(compute_moments(trans_john$samples_x) - theory_moment)
moment_error["Johnson MLE",] <- t(compute_moments(as.matrix(trans_john_mle$samples_x)) - theory_moment)
moment_error["Johnson perfect",] <- t(compute_moments(perfect_john$samples_x) -theory_moment)

# print the matrix
moment_error

nits_values <- seq(5e4,5e6,3e4)
perfect_error <- matrix(ncol = 5,nrow = length(nits_values))
colnames(perfect_error) <- c("nits","mean_diff","variance_diff","skew_diff","kurtosis_diff")
perfect_error[,"nits"] <- nits_values
for ( i in 1:length(nits_values)){
  print(i)
  nits <- nits_values[i]
  perfect_samples = lambda_john*sinh((rnorm(nits)-gamma_john)/delta_john)+xi_john
  perfect_error[i,2:5] <- t(compute_moments(as.matrix(perfect_samples))-theory_moment)
}
library(ggplot2)
library(reshape2)

# 转换数据格式
df <- as.data.frame(perfect_error)
df_long <- melt(df, id.vars = "nits", 
                measure.vars = c("mean_diff", "variance_diff", "skew_diff", "kurtosis_diff"))

# 绘图
ggplot(df_long, aes(x = nits, y = value)) +
  geom_line(color = "blue", size = 1) +
  facet_wrap(~variable, scales = "free_y") +
  labs(title = "Moments difference vs nits",
       x = "nits",
       y = "Difference") +
  theme_minimal()

```

```{r exploration the effect of each parameter}
nits = 50000
x_curr = 0
ESS_t0  = ESS_c  = ESS_delta = ESS_t1 =  NULL

# set the parameter values
t0_values <- seq(4,20000,200)
c_values <- c(1,10,50,100,300,500,1000)
delta_values <- c(0.5, 0.6, 0.7, 0.8, 0.9, 1)
t1_values <- c(1,5,10,50,100,500,1000,2000,3000,5000)


# calculate the ESS at different parameter values
for (i in (1:length(t0_values))){
  t0 <- t0_values[i]
  s <- Transformation_johnsonsu_mom (log_pi,nits,x_curr,t0 = t0, c= 500,delta = 0.55,t1= 3000)
  ESS_t0[i] <- effectiveSize(s$samples_x)
}


for (i in (1:length(c_values))){
  print(i)
  c <- c_values[i]
  s <- Transformation_johnsonsu_mom (log_pi,nits,x_curr,c = c)
  ESS_c[i] <- effectiveSize(s$samples_x)
}
for (i in (1:length(delta_values))){
  print(i)
  delta <- delta_values[i]
  s <- Transformation_johnsonsu_mom (log_pi,nits,x_curr,delta = delta,c=500)
  ESS_delta[i] <- effectiveSize(s$samples_x)
}

for (i in (1:length(t1_values))){
  print(i)
  t1 <- t1_values[i]
  time1 <- Sys.time()
  s <- Transformation_johnsonsu_mom (log_pi,nits,x_curr,t1 = t1,c = 500, delta = 0.5)
  time2 <- Sys.time()
  ESS_t1[i] <- effectiveSize(s$samples_x) / as.numeric(time2-time1,units = "secs")
}

# plot the ESS at different parameter values
plot(t0_values,ESS_t0,type = "l", xlab = "t0",ylab = "ESS",main = "ESS vs t0")
plot(c_values,ESS_c,type = "l", xlab = "c",ylab = "ESS",main = "ESS vs c")
plot(delta_values,ESS_delta,type = "l", xlab = "delta",ylab = "ESS",main = "ESS vs delta")
plot(t1_values,ESS_t1,type = "l", xlab = "t1",ylab = "ESS per sec",main = "ESS per sec vs t1")

# check the moment change over iteration
s <- Transformation_johnsonsu_mom(log_pi,nits,x_curr,c=500,delta = 0.5,t1 = 3000)
plot(1:nits,s$mu_store,type = "l",xlab = "iteration",ylab = "mean")
plot(1:nits,s$var_store,type = "l",xlab = "iteration",ylab = "variance")
plot(1:nits,s$skew_store,type = "l",xlab = "iteration",ylab = "skewness")
plot(1:nits,s$kurt_store,type = "l",xlab = "iteration",ylab = "kurtosis")


```




